\chapter{Trabalhos Relacionados}
\label{chapter:trabalhosRelacionados}

Vários estudos foram realizados anteriormente avaliando a evolução de diversos softwares. Alguns deles, chegam até a apresentar testes estatísticos e formulação matemática para descrever os resultados. Mas a grande maioria dos estudos são empíricos, realizando observação da evolução do software ao longo dos anos ou análise do histórico do software através repositórios de sistemas de controle de versão.

\cite{belady1976model} foi o trabalho pioneiro na área de evolução de software experimental. Realizando observações sobre o crescimento  de tamanho e complexidade de software, que levaram a postulação de cinco leis de evolução de software(Mudança Contínua, Incremento da Complexidade, A lei fundamental da Evolução de programas, Preservação da Estabilidade Organizacional e Conservação da Familiaridade), publicadas posteriormente em 1980.

\cite{chong1986empirical,yuen1987statistical,chong1988analyzing} realizou um estudo sistemático das leis de Lehman. Foram analisados dados de defeitos em um sistema de grande porte, descrevendo várias variáveis dependentes, relatando resultados focados na descoberta e correção de bugs. O estudo argumenta mostra que o tempo para a correção de um defeito não cresce com o tempo, ao contrário do que é esperado devido ao crecimento da complexidade do sistema. O estudo conclui dando suporte as duas primeiras leis, mas não sem comprovar as demais.

\cite{bendifallah1987understanding} análises comparativas de dois estudos de casos e revelam que tipos similares de sistemas de software em tipos próximos de características organizacionais tem trajetórias diferentes.

\cite{cook1994real} examinaram, por 18 meses, 10 versões de um sistema de tempo real na área de telefonia, focando na exploração de métricas de complexidade. Em seu estudo, suas observações dão suporte as Leis de Evolução de Lehman.

Em \cite{lehman1996laws}, é realizada uma análise experimental em um sistema da área financeira por 8 anos, com um total de 100 lançamentos( analisando destas, 21 versões). Para cada versão, foi analisado o número de módulos total e número de módulos modificados, observando que o crescimento do software estabiliza-se após a 6 versão. No trabalho, novas 3 leis são postuladas.

\cite{kemerer1997determinants} examinaram 621 modulos de software em 5 sistemas diferentes. No seu estudo, relatam que módulos de software estratégicos recebem mais atualizações do que os não estratégicos. Também observam que os software desenvolvido através de ferramentas de auxílio de desenvolvimento (ferramentas CASE) será menos reparado do que software escrito manualmente, assim como maiores atividades de manutenção em softwares de maior complexidade. Observam também que software mais antigo tende a ser mais atualizado e reparado do que software mais novo, que softwares maiores são atualizados, reparados e possuem mais manutenção preventiva do que softwares menores, e que 80\% dos defeitos estão em 20\% do código.

\cite{gall1997software} apresenta dados e observações oriundas no histórico de lançamentos de um grande sistema de telecomunicações. Em 20 versões, o crescimento deste sistema sustenta as tendências encontradas nos dados de Lehman, afirmando que a evolução global do sistema segue as leis de evolução de software, apesar de o mesmo não acontecer em subsistemas e módulos do mesmo.

Em \cite{schach2002maintainability} 365 versões sequencias do Linux Kernel (da versão 1.0 a versão
2.4).O estudo foca na evolução da manutenibilidade do software, e utiliza como métrica o número de ocorrências de acoplamento global, a ocorrência de compartilhamento de dados globais entre dois módulos diferentes (no contexto do trabalho, um módulo é tido como um arquivo de código fonte \textit{.c}).  Para cada versão, uma contagem do número de número ocorrências de acoplamento global foi realizada, entre 17 módulos e todos os outros módulos presentes na mesma versão. Segundo as observações dos autores, as ocorrências de acoplamento global crescem exponencialmente com o número da
versão, enquanto o crescimento do número de linhas de código
crescia apenas linearmente. Com estes resultados, os autores argumentam que
a menos que o projeto seja reestruturado visando um mínimo de acoplamentos globais, as
dependências introduzidas pelo acoplamento global tornaria o Linux difícil de ser mantido
sem a introdução de regressões.

\cite{scacchi2003understanding} faz uma análise das leis de evolução em softwares livres, descrevendo cinco entidades(Evolução sobre Releases, Sistema ou Programa, Aplicação, Processo, Modelos de Processos) para identificação dos participantes apropriados para examinar evolução de software. Fazendo uma leitura das leis de evolução de software no contexto de software livre, afirma que para o contexto do software livre, as leis devem ser revistas, adaptadas ou reavaliadas.

\cite{carver2004impact} analisam 12 projetos de software livre baseados em nos atributos tamanho, módulos, desenvolvedores, produtividade e versões, analisando a fundo mais a fundo 4 projetos no ponto de vista de evolução. O estudo apresenta estatísticas para analisar a evolução, realizando comparações entre atributos e sugerem que as observações feitas não podem ser generalizadas apra todo projeto de software livre. Em sua conclusão, relataram suporte às Leis de Lehman.

Em \cite{israeli2010linux}, um estudo da evolução do Linux Kernel é realizado. O estudo quantifica as características descritas pelas leis com métricas como complexidade ciclomática e índice de manutenibilidade de Ohman, além de análises estatísticas da evolução do projeto para avaliar se o mesmo obedece as Leis de Lehman. Como resultados, encontra-se suporte a várias leis como o crescimento contínuo(Lei 6) e a mudança constante(Lei 1), além de evidências de estabilidade organizacional(Lei 4), enquanto a prática de manutenção preventiva dá suporte a leis de aumento de complexidade(Lei 2) e qualidade decrescente (Lei 6), apontando que houveram esforços pra preveni-las. 

